# teknikioChallenge
coding challenge for Teknikio

[Hosted here](https://pedantic-curie-8fa8ce.netlify.app/)

## UX-UI Decisions 

Given that we have three types of blocks, trigger, timer and debug we know that only two of these blocks can produce output (trigger and timer).  The debug block merely displays this output.  We also know that the timer block is unable to produce a non-false output without the assistance of a trigger block as input. For the sake of things we can refer to an output of false as no output. Thus, forgetting about debug, the only valid configuration is Trigger-Timer because if we were to link Timer-Trigger there would be no possible way to interact with the system. However there is a case to consider with looping, If we were to say connect Trigger-Timer and then Timer back to Trigger we could have some sort of looping feedback system. Yet due to the nature of the Timers output and functionality this loop is not possible.  Imagining this loop is set up, when timer reaches 0 it sends out a True output back to the Trigger essentially pressing the Trigger and sending another True output to the timer. The reason this loop is not possible is because when the Timer recieves its first looped output from the Trigger, its Time reads 0 aka the condition for sending the True output in the first place. Thus on reception of this True from the trigger, nothing will happen. If we wanted this loop to be possible I could've reset the timer one second after reaching 0 but that was not a stipulation in the instructions thus no loop implementation. The only possible configs in my applicaiton are Debug-Trigger-Timer, Trigger-Debug-Timer, and Trigger-Timer-Debug.  Since there is essentially one connection that changes system behavours and outputs (Trigger-Timer) this connection is severable, whereas the debug connection is configuarable to reflect all changes in the system. 

## Code Decisions

Given that the 3 blocks are pre populated on the canvas we don't have to worry about extensibility and cases of anything other than the 3 blocks we are given existing at a given time. This is a big factor in using the library use-between rather than a true state manager like Redux. We really only need to know the state of 2 blocks (Trigger,Timer) and their connections which is essentially 4 variables, use-between was my choice because it's super lightweight and requires almost no explantion to understand how state is shared between components. The 4 variables we keep track of are as follows... `trigger`,`timer`,`debugConnection` and `mainConnection`. Triger and Timer are booleans that reflect their outputs respectively (`Timer=True` when it finishes)(`Trigger=True` when pressed). Connections are also variables that represent connections in the system (`MainConnection=True` when Trigger is connected to Timer) (`debugConnection` can be 1,2,3 depending if its connected to Timer,Debug or Both). Given these 4 varibles and given that each component knows them at any given time we are able to complete the task, here is a system walkthrough. 1-Trigger pressed (`Trigger=True` 1 sec) 2-(If `mainConnection=True`)Timer realizes trigger has been pressed and begins the countdown 3-Timer gets to 0 (Timer=True 1 sec). Based on `debugConnection` different parts of the system will be visible in the debug block.

## Extensibility 

If we were concerned with making a fully fledged app where blocks could be added at will and connections made anywhere the system design would have to be much different. We would have to implement routing algorithims to control the flow of information through the system. Each block (node) would have to have a dictionary of known connections and functions to handle the reception of information individually, rather than some sort of global state shared between all the nodes.
